// MY DSL

#define POP() StackPop(&stack)
#define PUSH(arg) StackPush(&stack, (arg))
#define CMD_FLAGS_ARE(arg) ((command & (arg)) == (arg))

DEF_CMD(HLT, 0x00, 0,
    {
        StackDtor(&stack);
        free(ptr);
        free(buffer);
        printf("end\n");
        return 0;
    }
)

DEF_CMD(PUSH, 0x01, 1,
    {
        if (CMD_FLAGS_ARE(OSU | REG | IMM))
        {
            ASSIGN_AND_GO_NEXT(reg_num, RegNum);
            ASSIGN_AND_GO_NEXT(index,   size_t);

            PUSH(RAM[(size_t)regs[reg_num] + index]);
        }
        else
        if (CMD_FLAGS_ARE(REG | OSU))
        {
            ASSIGN_AND_GO_NEXT(reg_num, RegNum);

            PUSH(RAM[(size_t)regs[reg_num]]);
        }
        else
        if (CMD_FLAGS_ARE(OSU))
        {
            ASSIGN_AND_GO_NEXT(index, size_t);

            PUSH(RAM[index]);
        }
        else
        if (CMD_FLAGS_ARE(REG))
        {
            ASSIGN_AND_GO_NEXT(reg_num, RegNum);

            PUSH(regs[reg_num]);
        }
        else
        if (CMD_FLAGS_ARE(IMM))
        {
            ASSIGN_AND_GO_NEXT(num, Elem_t);

            PUSH(num);
        }
        else
        {
            perror("HOW DOES IT FEEL TO GO WHERE IS NO ALLOWED");
            StackDump(&stack);
        }
    }
)

DEF_CMD(POP, 0x02, 1,
    {
        if (CMD_FLAGS_ARE(OSU | REG | IMM))
        {
            ASSIGN_AND_GO_NEXT(reg_num, RegNum);
            ASSIGN_AND_GO_NEXT(index,   size_t);

            RAM[(size_t)regs[reg_num] + index] = POP();
        }
        else
        if (CMD_FLAGS_ARE(REG | OSU))
        {
            ASSIGN_AND_GO_NEXT(reg_num, RegNum);

            RAM[(size_t)regs[reg_num]] = POP();
        }
        else
        if (CMD_FLAGS_ARE(OSU))
        {
            ASSIGN_AND_GO_NEXT(index, size_t);

            RAM[index] = POP();
        }
        else
        if (CMD_FLAGS_ARE(REG))
        {
            ASSIGN_AND_GO_NEXT(reg_num, RegNum);

            regs[reg_num] = POP();
        }
        else
        {
            perror("HOW DOES IT FEEL TO GO WHERE IS NO ALLOWED");
            StackDump(&stack);
        }
    }
)
 
DEF_CMD(ADD, 0x03, 0,
    {
        PUSH(POP()+POP());
    }
)

DEF_CMD(MUL, 0x04, 0,
    {
        PUSH(POP() * POP());
    }
)

DEF_CMD(SUB, 0x05, 0,
    {
        Elem_t x = 0;
        x -= POP();
        x += POP();

        if (isnan(x))
        {
            PROCESSING_ERROR(WRONG_SEQ_OF_COMMANDS_STACK_POPPING_WHEN_EMPTY);
        }
        
        PUSH(x);
    }
)

DEF_CMD(DIV, 0x06, 0,
    {
        Elem_t x = 1;
        x /= POP();
        x *= POP();

        if (isnan(x))
        {
            PROCESSING_ERROR(WRONG_SEQ_OF_COMMANDS_STACK_POPPING_WHEN_EMPTY);
        }

        PUSH(x);
    }
)

DEF_CMD(OUT, 0x07, 0,
    {
        Elem_t x = StackTop(&stack);

        if (isnan(x))
        {
            PROCESSING_ERROR(WRONG_SEQ_OF_COMMANDS_STACK_TOP_WHEN_EMPTY);
        }

        printf("top = %lf\n", x);
        sleep(1);
    }
)

DEF_CMD(DUMP, 0x08, 0,
    {
        // TODO
        printf("dump\n");
    }
)

DEF_CMD(MEOW, 0x1F, 0,
    {
        printf("meow :3\n");
    }
)

DEF_JMP(JMP, 0x10, || 1 ||)
DEF_JMP(JA,  0x11, >)
DEF_JMP(JAE, 0x12, >=)
DEF_JMP(JE,  0x13, ==)
DEF_JMP(JBE, 0x14, <)
DEF_JMP(JB,  0x15, <=)
DEF_JMP(JNE, 0x16, !=)

#undef POP
#undef PUSH
#undef CMD_FLAGS_ARE
